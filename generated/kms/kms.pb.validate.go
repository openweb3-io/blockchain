// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: kms/kms.proto

package kms

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on ImportKeyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportKeyRequestMultiError, or nil if none found.
func (m *ImportKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Description

	// no validation rules for KeyUsage

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportKeyRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportKeyRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportKeyRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Metadata

	// no validation rules for Extra

	// no validation rules for Material

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if m.Chain != nil {
		// no validation rules for Chain
	}

	if m.KeySpec != nil {
		// no validation rules for KeySpec
	}

	if len(errors) > 0 {
		return ImportKeyRequestMultiError(errors)
	}

	return nil
}

// ImportKeyRequestMultiError is an error wrapping multiple validation errors
// returned by ImportKeyRequest.ValidateAll() if the designated constraints
// aren't met.
type ImportKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportKeyRequestMultiError) AllErrors() []error { return m }

// ImportKeyRequestValidationError is the validation error returned by
// ImportKeyRequest.Validate if the designated constraints aren't met.
type ImportKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportKeyRequestValidationError) ErrorName() string { return "ImportKeyRequestValidationError" }

// Error satisfies the builtin error interface
func (e ImportKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportKeyRequestValidationError{}

// Validate checks the field values on ImportKeyReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ImportKeyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportKeyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ImportKeyReplyMultiError,
// or nil if none found.
func (m *ImportKeyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportKeyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for Metadata

	// no validation rules for Extra

	// no validation rules for Chain

	// no validation rules for KeySpec

	// no validation rules for KeyUsage

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ImportKeyReplyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ImportKeyReplyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ImportKeyReplyValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportKeyReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportKeyReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportKeyReplyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ImportKeyReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ImportKeyReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ImportKeyReplyValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if len(errors) > 0 {
		return ImportKeyReplyMultiError(errors)
	}

	return nil
}

// ImportKeyReplyMultiError is an error wrapping multiple validation errors
// returned by ImportKeyReply.ValidateAll() if the designated constraints
// aren't met.
type ImportKeyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportKeyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportKeyReplyMultiError) AllErrors() []error { return m }

// ImportKeyReplyValidationError is the validation error returned by
// ImportKeyReply.Validate if the designated constraints aren't met.
type ImportKeyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportKeyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportKeyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportKeyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportKeyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportKeyReplyValidationError) ErrorName() string { return "ImportKeyReplyValidationError" }

// Error satisfies the builtin error interface
func (e ImportKeyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportKeyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportKeyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportKeyReplyValidationError{}

// Validate checks the field values on EnableKeyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EnableKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EnableKeyRequestMultiError, or nil if none found.
func (m *EnableKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	if len(errors) > 0 {
		return EnableKeyRequestMultiError(errors)
	}

	return nil
}

// EnableKeyRequestMultiError is an error wrapping multiple validation errors
// returned by EnableKeyRequest.ValidateAll() if the designated constraints
// aren't met.
type EnableKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableKeyRequestMultiError) AllErrors() []error { return m }

// EnableKeyRequestValidationError is the validation error returned by
// EnableKeyRequest.Validate if the designated constraints aren't met.
type EnableKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableKeyRequestValidationError) ErrorName() string { return "EnableKeyRequestValidationError" }

// Error satisfies the builtin error interface
func (e EnableKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableKeyRequestValidationError{}

// Validate checks the field values on EnableKeyReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *EnableKeyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EnableKeyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in EnableKeyReplyMultiError,
// or nil if none found.
func (m *EnableKeyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *EnableKeyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	if len(errors) > 0 {
		return EnableKeyReplyMultiError(errors)
	}

	return nil
}

// EnableKeyReplyMultiError is an error wrapping multiple validation errors
// returned by EnableKeyReply.ValidateAll() if the designated constraints
// aren't met.
type EnableKeyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EnableKeyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EnableKeyReplyMultiError) AllErrors() []error { return m }

// EnableKeyReplyValidationError is the validation error returned by
// EnableKeyReply.Validate if the designated constraints aren't met.
type EnableKeyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EnableKeyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EnableKeyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EnableKeyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EnableKeyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EnableKeyReplyValidationError) ErrorName() string { return "EnableKeyReplyValidationError" }

// Error satisfies the builtin error interface
func (e EnableKeyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEnableKeyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EnableKeyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EnableKeyReplyValidationError{}

// Validate checks the field values on DisableKeyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DisableKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisableKeyRequestMultiError, or nil if none found.
func (m *DisableKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	if len(errors) > 0 {
		return DisableKeyRequestMultiError(errors)
	}

	return nil
}

// DisableKeyRequestMultiError is an error wrapping multiple validation errors
// returned by DisableKeyRequest.ValidateAll() if the designated constraints
// aren't met.
type DisableKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableKeyRequestMultiError) AllErrors() []error { return m }

// DisableKeyRequestValidationError is the validation error returned by
// DisableKeyRequest.Validate if the designated constraints aren't met.
type DisableKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableKeyRequestValidationError) ErrorName() string {
	return "DisableKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DisableKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableKeyRequestValidationError{}

// Validate checks the field values on DisableKeyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DisableKeyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DisableKeyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DisableKeyReplyMultiError, or nil if none found.
func (m *DisableKeyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DisableKeyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	if len(errors) > 0 {
		return DisableKeyReplyMultiError(errors)
	}

	return nil
}

// DisableKeyReplyMultiError is an error wrapping multiple validation errors
// returned by DisableKeyReply.ValidateAll() if the designated constraints
// aren't met.
type DisableKeyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DisableKeyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DisableKeyReplyMultiError) AllErrors() []error { return m }

// DisableKeyReplyValidationError is the validation error returned by
// DisableKeyReply.Validate if the designated constraints aren't met.
type DisableKeyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DisableKeyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DisableKeyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DisableKeyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DisableKeyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DisableKeyReplyValidationError) ErrorName() string { return "DisableKeyReplyValidationError" }

// Error satisfies the builtin error interface
func (e DisableKeyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDisableKeyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DisableKeyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DisableKeyReplyValidationError{}

// Validate checks the field values on DescribeKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *DescribeKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DescribeKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DescribeKeyRequestMultiError, or nil if none found.
func (m *DescribeKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *DescribeKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	if len(errors) > 0 {
		return DescribeKeyRequestMultiError(errors)
	}

	return nil
}

// DescribeKeyRequestMultiError is an error wrapping multiple validation errors
// returned by DescribeKeyRequest.ValidateAll() if the designated constraints
// aren't met.
type DescribeKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeKeyRequestMultiError) AllErrors() []error { return m }

// DescribeKeyRequestValidationError is the validation error returned by
// DescribeKeyRequest.Validate if the designated constraints aren't met.
type DescribeKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeKeyRequestValidationError) ErrorName() string {
	return "DescribeKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeKeyRequestValidationError{}

// Validate checks the field values on DescribeKeyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DescribeKeyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DescribeKeyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DescribeKeyReplyMultiError, or nil if none found.
func (m *DescribeKeyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *DescribeKeyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	// no validation rules for KeySpec

	// no validation rules for Chain

	// no validation rules for Description

	// no validation rules for Metadata

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DescribeKeyReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DescribeKeyReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DescribeKeyReplyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, DescribeKeyReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, DescribeKeyReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return DescribeKeyReplyValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if len(errors) > 0 {
		return DescribeKeyReplyMultiError(errors)
	}

	return nil
}

// DescribeKeyReplyMultiError is an error wrapping multiple validation errors
// returned by DescribeKeyReply.ValidateAll() if the designated constraints
// aren't met.
type DescribeKeyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeKeyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeKeyReplyMultiError) AllErrors() []error { return m }

// DescribeKeyReplyValidationError is the validation error returned by
// DescribeKeyReply.Validate if the designated constraints aren't met.
type DescribeKeyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeKeyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeKeyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeKeyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeKeyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeKeyReplyValidationError) ErrorName() string { return "DescribeKeyReplyValidationError" }

// Error satisfies the builtin error interface
func (e DescribeKeyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeKeyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeKeyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeKeyReplyValidationError{}

// Validate checks the field values on Tag with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Tag) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Tag with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TagMultiError, or nil if none found.
func (m *Tag) ValidateAll() error {
	return m.validate(true)
}

func (m *Tag) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Key != nil {
		// no validation rules for Key
	}

	if m.Value != nil {
		// no validation rules for Value
	}

	if len(errors) > 0 {
		return TagMultiError(errors)
	}

	return nil
}

// TagMultiError is an error wrapping multiple validation errors returned by
// Tag.ValidateAll() if the designated constraints aren't met.
type TagMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagMultiError) AllErrors() []error { return m }

// TagValidationError is the validation error returned by Tag.Validate if the
// designated constraints aren't met.
type TagValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagValidationError) ErrorName() string { return "TagValidationError" }

// Error satisfies the builtin error interface
func (e TagValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTag.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagValidationError{}

// Validate checks the field values on TagResourceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TagResourceRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TagResourceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TagResourceRequestMultiError, or nil if none found.
func (m *TagResourceRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *TagResourceRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TagResourceRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TagResourceRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TagResourceRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return TagResourceRequestMultiError(errors)
	}

	return nil
}

// TagResourceRequestMultiError is an error wrapping multiple validation errors
// returned by TagResourceRequest.ValidateAll() if the designated constraints
// aren't met.
type TagResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagResourceRequestMultiError) AllErrors() []error { return m }

// TagResourceRequestValidationError is the validation error returned by
// TagResourceRequest.Validate if the designated constraints aren't met.
type TagResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagResourceRequestValidationError) ErrorName() string {
	return "TagResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e TagResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTagResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagResourceRequestValidationError{}

// Validate checks the field values on TagResourceReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TagResourceReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TagResourceReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TagResourceReplyMultiError, or nil if none found.
func (m *TagResourceReply) ValidateAll() error {
	return m.validate(true)
}

func (m *TagResourceReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return TagResourceReplyMultiError(errors)
	}

	return nil
}

// TagResourceReplyMultiError is an error wrapping multiple validation errors
// returned by TagResourceReply.ValidateAll() if the designated constraints
// aren't met.
type TagResourceReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TagResourceReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TagResourceReplyMultiError) AllErrors() []error { return m }

// TagResourceReplyValidationError is the validation error returned by
// TagResourceReply.Validate if the designated constraints aren't met.
type TagResourceReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TagResourceReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TagResourceReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TagResourceReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TagResourceReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TagResourceReplyValidationError) ErrorName() string { return "TagResourceReplyValidationError" }

// Error satisfies the builtin error interface
func (e TagResourceReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTagResourceReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TagResourceReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TagResourceReplyValidationError{}

// Validate checks the field values on CreateKeyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CreateKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateKeyRequestMultiError, or nil if none found.
func (m *CreateKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Description

	// no validation rules for KeyUsage

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateKeyRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateKeyRequestValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateKeyRequestValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Metadata

	// no validation rules for Extra

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if m.Chain != nil {
		// no validation rules for Chain
	}

	if m.KeySpec != nil {
		// no validation rules for KeySpec
	}

	if len(errors) > 0 {
		return CreateKeyRequestMultiError(errors)
	}

	return nil
}

// CreateKeyRequestMultiError is an error wrapping multiple validation errors
// returned by CreateKeyRequest.ValidateAll() if the designated constraints
// aren't met.
type CreateKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateKeyRequestMultiError) AllErrors() []error { return m }

// CreateKeyRequestValidationError is the validation error returned by
// CreateKeyRequest.Validate if the designated constraints aren't met.
type CreateKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateKeyRequestValidationError) ErrorName() string { return "CreateKeyRequestValidationError" }

// Error satisfies the builtin error interface
func (e CreateKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateKeyRequestValidationError{}

// Validate checks the field values on CreateKeyReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CreateKeyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateKeyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CreateKeyReplyMultiError,
// or nil if none found.
func (m *CreateKeyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateKeyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for Metadata

	// no validation rules for Extra

	// no validation rules for Chain

	// no validation rules for KeySpec

	// no validation rules for KeyUsage

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateKeyReplyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateKeyReplyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateKeyReplyValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateKeyReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateKeyReplyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateKeyReplyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CreateKeyReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CreateKeyReplyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CreateKeyReplyValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if len(errors) > 0 {
		return CreateKeyReplyMultiError(errors)
	}

	return nil
}

// CreateKeyReplyMultiError is an error wrapping multiple validation errors
// returned by CreateKeyReply.ValidateAll() if the designated constraints
// aren't met.
type CreateKeyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateKeyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateKeyReplyMultiError) AllErrors() []error { return m }

// CreateKeyReplyValidationError is the validation error returned by
// CreateKeyReply.Validate if the designated constraints aren't met.
type CreateKeyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateKeyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateKeyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateKeyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateKeyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateKeyReplyValidationError) ErrorName() string { return "CreateKeyReplyValidationError" }

// Error satisfies the builtin error interface
func (e CreateKeyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateKeyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateKeyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateKeyReplyValidationError{}

// Validate checks the field values on Key with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Key) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Key with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KeyMultiError, or nil if none found.
func (m *Key) ValidateAll() error {
	return m.validate(true)
}

func (m *Key) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	// no validation rules for Description

	// no validation rules for Metadata

	// no validation rules for Extra

	// no validation rules for Chain

	// no validation rules for KeySpec

	// no validation rules for KeyUsage

	for idx, item := range m.GetTags() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, KeyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, KeyValidationError{
						field:  fmt.Sprintf("Tags[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return KeyValidationError{
					field:  fmt.Sprintf("Tags[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyValidationError{
					field:  "CreatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyValidationError{
				field:  "CreatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdatedAt()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, KeyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, KeyValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return KeyValidationError{
				field:  "UpdatedAt",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if m.Uid != nil {
		// no validation rules for Uid
	}

	if len(errors) > 0 {
		return KeyMultiError(errors)
	}

	return nil
}

// KeyMultiError is an error wrapping multiple validation errors returned by
// Key.ValidateAll() if the designated constraints aren't met.
type KeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyMultiError) AllErrors() []error { return m }

// KeyValidationError is the validation error returned by Key.Validate if the
// designated constraints aren't met.
type KeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValidationError) ErrorName() string { return "KeyValidationError" }

// Error satisfies the builtin error interface
func (e KeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValidationError{}

// Validate checks the field values on SignRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignRequestMultiError, or
// nil if none found.
func (m *SignRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	// no validation rules for Message

	// no validation rules for SigningAlgorithm

	// no validation rules for MessageType

	if len(errors) > 0 {
		return SignRequestMultiError(errors)
	}

	return nil
}

// SignRequestMultiError is an error wrapping multiple validation errors
// returned by SignRequest.ValidateAll() if the designated constraints aren't met.
type SignRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignRequestMultiError) AllErrors() []error { return m }

// SignRequestValidationError is the validation error returned by
// SignRequest.Validate if the designated constraints aren't met.
type SignRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignRequestValidationError) ErrorName() string { return "SignRequestValidationError" }

// Error satisfies the builtin error interface
func (e SignRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignRequestValidationError{}

// Validate checks the field values on SignReply with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignReply with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignReplyMultiError, or nil
// if none found.
func (m *SignReply) ValidateAll() error {
	return m.validate(true)
}

func (m *SignReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	// no validation rules for Signature

	if len(errors) > 0 {
		return SignReplyMultiError(errors)
	}

	return nil
}

// SignReplyMultiError is an error wrapping multiple validation errors returned
// by SignReply.ValidateAll() if the designated constraints aren't met.
type SignReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignReplyMultiError) AllErrors() []error { return m }

// SignReplyValidationError is the validation error returned by
// SignReply.Validate if the designated constraints aren't met.
type SignReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignReplyValidationError) ErrorName() string { return "SignReplyValidationError" }

// Error satisfies the builtin error interface
func (e SignReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignReplyValidationError{}

// Validate checks the field values on GetPublicKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *GetPublicKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPublicKeyRequestMultiError, or nil if none found.
func (m *GetPublicKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	if len(errors) > 0 {
		return GetPublicKeyRequestMultiError(errors)
	}

	return nil
}

// GetPublicKeyRequestMultiError is an error wrapping multiple validation
// errors returned by GetPublicKeyRequest.ValidateAll() if the designated
// constraints aren't met.
type GetPublicKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicKeyRequestMultiError) AllErrors() []error { return m }

// GetPublicKeyRequestValidationError is the validation error returned by
// GetPublicKeyRequest.Validate if the designated constraints aren't met.
type GetPublicKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicKeyRequestValidationError) ErrorName() string {
	return "GetPublicKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicKeyRequestValidationError{}

// Validate checks the field values on GetPublicKeyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetPublicKeyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetPublicKeyReply with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetPublicKeyReplyMultiError, or nil if none found.
func (m *GetPublicKeyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *GetPublicKeyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AppId

	// no validation rules for Id

	// no validation rules for PublicKey

	if len(errors) > 0 {
		return GetPublicKeyReplyMultiError(errors)
	}

	return nil
}

// GetPublicKeyReplyMultiError is an error wrapping multiple validation errors
// returned by GetPublicKeyReply.ValidateAll() if the designated constraints
// aren't met.
type GetPublicKeyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPublicKeyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPublicKeyReplyMultiError) AllErrors() []error { return m }

// GetPublicKeyReplyValidationError is the validation error returned by
// GetPublicKeyReply.Validate if the designated constraints aren't met.
type GetPublicKeyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPublicKeyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPublicKeyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPublicKeyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPublicKeyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPublicKeyReplyValidationError) ErrorName() string {
	return "GetPublicKeyReplyValidationError"
}

// Error satisfies the builtin error interface
func (e GetPublicKeyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPublicKeyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPublicKeyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPublicKeyReplyValidationError{}

// Validate checks the field values on ListKeyRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListKeyRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListKeyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListKeyRequestMultiError,
// or nil if none found.
func (m *ListKeyRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListKeyRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Limit

	if m.AppId != nil {
		// no validation rules for AppId
	}

	if m.Cursor != nil {
		// no validation rules for Cursor
	}

	if len(errors) > 0 {
		return ListKeyRequestMultiError(errors)
	}

	return nil
}

// ListKeyRequestMultiError is an error wrapping multiple validation errors
// returned by ListKeyRequest.ValidateAll() if the designated constraints
// aren't met.
type ListKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListKeyRequestMultiError) AllErrors() []error { return m }

// ListKeyRequestValidationError is the validation error returned by
// ListKeyRequest.Validate if the designated constraints aren't met.
type ListKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListKeyRequestValidationError) ErrorName() string { return "ListKeyRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListKeyRequestValidationError{}

// Validate checks the field values on ListKeyReply with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ListKeyReply) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListKeyReply with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ListKeyReplyMultiError, or
// nil if none found.
func (m *ListKeyReply) ValidateAll() error {
	return m.validate(true)
}

func (m *ListKeyReply) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetData() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListKeyReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListKeyReplyValidationError{
						field:  fmt.Sprintf("Data[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListKeyReplyValidationError{
					field:  fmt.Sprintf("Data[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for HasNext

	// no validation rules for HasPrev

	if m.EndCursor != nil {
		// no validation rules for EndCursor
	}

	if m.StartCursor != nil {
		// no validation rules for StartCursor
	}

	if len(errors) > 0 {
		return ListKeyReplyMultiError(errors)
	}

	return nil
}

// ListKeyReplyMultiError is an error wrapping multiple validation errors
// returned by ListKeyReply.ValidateAll() if the designated constraints aren't met.
type ListKeyReplyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListKeyReplyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListKeyReplyMultiError) AllErrors() []error { return m }

// ListKeyReplyValidationError is the validation error returned by
// ListKeyReply.Validate if the designated constraints aren't met.
type ListKeyReplyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListKeyReplyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListKeyReplyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListKeyReplyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListKeyReplyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListKeyReplyValidationError) ErrorName() string { return "ListKeyReplyValidationError" }

// Error satisfies the builtin error interface
func (e ListKeyReplyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListKeyReply.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListKeyReplyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListKeyReplyValidationError{}
